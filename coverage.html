
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2023_2_Hamster/internal/common/http/request_handler.go (100.0%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2023_2_Hamster/internal/common/http/response.go (68.4%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2023_2_Hamster/internal/common/logger/logger.go (100.0%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/category.go (0.0%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/credit.go (0.0%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/debt.go (0.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/deposit.go (0.0%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/error.go (80.0%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/goal.go (0.0%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/investmet.go (0.0%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/transaction.go (0.0%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2023_2_Hamster/internal/models/user.go (33.3%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2023_2_Hamster/internal/pkg/user/delivery/http/handlers.go (100.0%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2023_2_Hamster/internal/pkg/user/usecase/user_usecase.go (52.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "errors"
        "net/http"

        "github.com/google/uuid"
        "github.com/gorilla/mux"
)

func GetIDFromRequest(id string, r *http.Request) (uuid.UUID, error) <span class="cov8" title="1">{
        uuidString := mux.Vars(r)[id]
        parsedUUID, err := uuid.Parse(uuidString)

        if err != nil </span><span class="cov8" title="1">{
                return parsedUUID, errors.New("invalid uuid parameter")
        }</span>
        <span class="cov8" title="1">return parsedUUID, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package http

import (
        "encoding/json"
        "net/http"

        "github.com/go-park-mail-ru/2023_2_Hamster/internal/common/logger"
)

const (
        InvalidURLParameter = "invalid url parameter"
)

type Error struct {
        Status int    `json:"status"`
        ErrMes string `json:"message"`
}

type NilBody struct{}

type Response[T any] struct {
        Status int `json:"status"`
        Body   T   `json:"body"`
}

func NIL() NilBody <span class="cov0" title="0">{
        return NilBody{}
}</span>

const minErrorToLogCode = 500

func ErrorResponse(w http.ResponseWriter, code int, err error, message string, log logger.CustomLogger) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(code)

        errorMsg := Error{
                Status: code,
                ErrMes: message,
        }

        if code &lt; minErrorToLogCode </span><span class="cov8" title="1">{
                log.Infof("invalid id: %v:", err)
        }</span> else<span class="cov8" title="1"> {
                log.Error(err.Error())
        }</span>

        <span class="cov8" title="1">encoder := json.NewEncoder(w)
        if err := encoder.Encode(errorMsg); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error failed to marshal error message: %s", err.Error())
                w.WriteHeader(http.StatusInternalServerError)
                w.Write([]byte("Can't encode error message into json, massage: " + message))
        }</span>
}

func SuccessResponse[T any](w http.ResponseWriter, status int, response T) <span class="cov8" title="1">{
        date := Response[T]{Status: status, Body: response}
        encoder := json.NewEncoder(w)
        if err := encoder.Encode(date); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(status)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        // w.Header().Set("Content-Length", )
        w.WriteHeader(status)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package logger

import (
        "os"

        "github.com/sirupsen/logrus"
)

type CustomLogger struct {
        *logrus.Logger
}

func CreateCustomLogger() *CustomLogger <span class="cov8" title="1">{
        logger := logrus.New()
        logger.SetLevel(logrus.DebugLevel)
        logger.SetFormatter(&amp;logrus.TextFormatter{
                FullTimestamp: true,
        })
        logger.SetOutput(os.Stdout)
        return &amp;CustomLogger{Logger: logger}
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type Category struct {
        ID     uuid.UUID `json:"id" valid:"-"`
        UserID uint      `json:"user_id" valid:"-"`
        Name   string    `json:"name" valid:"required"`
}

func (c *Category) CategoryValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(c)
        return err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "time"

        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type Credit struct {
        ID          uuid.UUID `json:"id" valid:"-"`
        AccountID   uint      `json:"account_id" valid:"-"`
        Total       float64   `json:"total" valid:"required,greaterzero"`
        DateStart   time.Time `json:"date_start" valid:"isdate"`
        DateEnd     time.Time `json:"date_end" valid:"isdate"`
        IsAnnuity   bool      `json:"is_annuity" valid:"required"`
        Creditor    string    `json:"creditor" valid:"-"`
        Description string    `json:"description" valid:"-"`
        Payments    int       `json:"payments" valid:"-"`
        Bank        string    `json:"bank" valid:"-"`
}

func (c *Credit) CreditValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(c)
        return err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "time"

        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type Debt struct {
        ID          uuid.UUID `json:"id" valid:"-"`
        UserID      uint      `json:"user_id" valid:"-"`
        Total       float64   `json:"total" valid:"required,greaterzero"`
        Date        time.Time `json:"date" valid:"isdate"`
        Creditor    string    `json:"creditor"`
        Description string    `json:"description" valid:"-"`
}

func (d *Debt) DebtValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(d)
        return err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import (
        "time"

        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type Deposit struct {
        ID           uuid.UUID `json:"id" valid:"-"`
        AccountID    uint      `json:"account_id" valid:"-"`
        Total        float64   `json:"total" valid:"required,greaterzero"`
        DateStart    time.Time `json:"date_start" valid:"isdate"`
        DateEnd      time.Time `json:"date_end" valid:"isdate"`
        InterestRate float64   `json:"interest_rate" valid:"required"`
        Bank         string    `json:"bank"`
}

func (d *Deposit) DepositValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(d)
        return err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "fmt"

        "github.com/google/uuid"
)

type NoSuchUserError struct {
        UserID uuid.UUID
}

type NoSuchUserIdBalanceError struct {
        UserID uuid.UUID
}

type NoSuchCurrentBudget struct {
        UserID uuid.UUID
}

type NoSuchPlannedBudgetError struct {
        UserID uuid.UUID
}

type NoSuchAccounts struct {
        UserID uuid.UUID
}

func (e *NoSuchUserIdBalanceError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("balance from user: %s doesn't exist", e.UserID.String())
}</span>

func (e *NoSuchPlannedBudgetError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("planned budget from user: %s doesn't exist", e.UserID.String())
}</span>

func (e *NoSuchCurrentBudget) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("actual budget from user: %s doesn't exist", e.UserID.String())
}</span>

func (e *NoSuchAccounts) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("No Such Accounts from user: %s doesn't exist", e.UserID.String())
}</span>

func (e *NoSuchUserError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("No Such user: %s doesn't exist", e.UserID.String())
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "time"

        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type Goal struct {
        ID          uuid.UUID `json:"id" valid:"-"`
        UserID      uint      `json:"user_id" valid:"-"`
        Name        string    `json:"name" valid:"required"`
        Description string    `json:"description" valid:"-"`
        Total       float64   `json:"total" valid:"required,greaterzero"`
        Date        time.Time `json:"date" valid:"isdate"`
}

func (g *Goal) GoalValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(g)
        return err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "time"

        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type Investment struct {
        ID         uuid.UUID `json:"id" valid:"-"`
        UserID     uint      `json:"user_id" valid:"-"`
        Name       string    `json:"name" valid:"required"`
        Total      float64   `json:"total" valid:"required,greaterzero"`
        DateStart  time.Time `json:"date_start" valid:"isdate"`
        DateEnd    time.Time `json:"date_end" valid:"isdate"`
        Price      float64   `json:"price" valid:"required"`
        Percentage float64   `json:"percentage" valid:"required"`
}

func (i *Investment) InvestmentValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(i)
        return err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package models

import (
        "time"

        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type Transaction struct {
        ID          uuid.UUID `json:"id" valid:"-"`
        UserID      uint      `json:"user_id" valid:"-"`
        CategoryID  uint      `json:"category_id" valid:"-"`
        AccountID   uint      `json:"account_id" valid:"-"`
        Total       float64   `json:"total" valid:"required,greaterzero"`
        IsIncome    bool      `json:"is_income" valid:"required"`
        Date        time.Time `json:"date" valid:"isdate"`
        Payer       string    `json:"payer" valid:"payer"`
        Description string    `json:"description" valid:"-"`
}

func (t *Transaction) TransactionValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(t)
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

import (
        valid "github.com/asaskevich/govalidator"
        "github.com/google/uuid"
)

type User struct {
        ID            uuid.UUID `json:"id" valid:"-"`
        Username      string    `json:"username" valid:"-"`
        PlannedBudget float64   `json:"planned_budget" valid:"-"`
        Password      string    `json:"password" valid:"required,runelength(7|30),passwordcheck"`
        AvatarURL     string    `json:"avatar_url" vaild:"-"`
        Salt          string    `json:"salt"`
}

type ContextKeyUserType struct{}

func (u *User) UserValidate() error <span class="cov0" title="0">{
        _, err := valid.ValidateStruct(u)
        return err
}</span>

type UserTransfer struct {
        ID            uuid.UUID `json:"id"`
        Username      string    `json:"username"`
        PlannedBudget float64   `json:"planned_budget"`
        AvatarURL     string    `json:"avatar_url"`
}

func InitUserTransfer(user User) UserTransfer <span class="cov8" title="1">{
        return UserTransfer{
                ID:            user.ID,
                Username:      user.Username,
                PlannedBudget: user.PlannedBudget,
                AvatarURL:     user.AvatarURL,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package http

import (
        "errors"
        "net/http"

        commonHttp "github.com/go-park-mail-ru/2023_2_Hamster/internal/common/http"
        "github.com/go-park-mail-ru/2023_2_Hamster/internal/common/logger"
        "github.com/go-park-mail-ru/2023_2_Hamster/internal/models"
        "github.com/go-park-mail-ru/2023_2_Hamster/internal/pkg/user"
        "github.com/go-park-mail-ru/2023_2_Hamster/internal/pkg/user/delivery/http/transfer_models"
)

type Handler struct {
        userService user.Usecase
        logger      logger.CustomLogger
}

const (
        userIdUrlParam = "userID"
)

func NewHandler(uu user.Usecase, l logger.CustomLogger) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                userService: uu,
                logger:      l,
        }
}</span>

// @Summary                Get User
// @Tags                User
// @Description        Get user with chosen ID
// @Produce                json
// @Success                200                {object}        Response[models.usrTranfer] "Show balance"
// @Failure                400                {object}        http.Error        "Client error"
// @Failure                500                {object}        http.Error        "Server error"
func (h *Handler) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := commonHttp.GetIDFromRequest(userIdUrlParam, r)
        if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, commonHttp.InvalidURLParameter, h.logger)
                return
        }</span>

        <span class="cov8" title="1">var errNoSuchUser *models.NoSuchUserError
        usr, err := h.userService.GetUser(userID)
        if errors.As(err, &amp;errNoSuchUser) </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, transfer_models.UserNotFound, h.logger)
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusInternalServerError, err, transfer_models.UserServerError, h.logger)
                return
        }</span>

        <span class="cov8" title="1">usrTranfer := models.InitUserTransfer(*usr)

        commonHttp.SuccessResponse(w, http.StatusOK, usrTranfer)</span>
}

// @Summary                Get Balance
// @Tags                        User
// @Description        Get User balance
// @Produce                json
// @Success                200                {object}        Response[transfer_models.BalanceResponse] "Show balance"
// @Failure                400                {object}        http.Error        "Client error"
// @Failure                500                {object}        http.Error        "Server error"
// @Router                /api/user/{userID}/balance [get]
func (h *Handler) GetUserBalance(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := commonHttp.GetIDFromRequest(userIdUrlParam, r)
        if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, commonHttp.InvalidURLParameter, h.logger)
                return
        }</span>
        <span class="cov8" title="1">balance, err := h.userService.GetUserBalance(userID)

        var errNoSuchUserIdBalanceError *models.NoSuchUserIdBalanceError
        if errors.As(err, &amp;errNoSuchUserIdBalanceError) </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, transfer_models.BalanceNotFound, h.logger)
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusInternalServerError, err, transfer_models.BalanceGetServerError, h.logger)
                return
        }</span>

        <span class="cov8" title="1">response := transfer_models.BalanceResponse{Balance: balance}
        commonHttp.SuccessResponse[transfer_models.BalanceResponse](w, http.StatusOK, response)</span>
}

// @Summary                Get Planned Budget
// @Tags                        User
// @Description        Get User planned budget
// @Produce                json
// @Success                200                {object}         Response[transfer_models.BudgetPlannedResponse]        "Show planned budget"
// @Failure                400                {object}        http.Error                        "Client error"
// @Failure                500                {object}        http.Error                        "Server error"
// @Router                /api/user/{userID}/plannedBudget [get]
func (h *Handler) GetPlannedBudget(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := commonHttp.GetIDFromRequest(userIdUrlParam, r)

        if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, commonHttp.InvalidURLParameter, h.logger)
                return
        }</span>

        <span class="cov8" title="1">budget, err := h.userService.GetPlannedBudget(userID)

        var errNoSuchPlannedBudgetError *models.NoSuchPlannedBudgetError
        if errors.As(err, &amp;errNoSuchPlannedBudgetError) </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, transfer_models.PlannedBudgetNotFound, h.logger)
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusInternalServerError, err, transfer_models.PlannedBudgetGetServerError, h.logger)
                return
        }</span>

        <span class="cov8" title="1">response := transfer_models.BudgetPlannedResponse{BudgetPlanned: budget}
        commonHttp.SuccessResponse[transfer_models.BudgetPlannedResponse](w, http.StatusOK, response)</span>
}

// @Summary                Get Actual Budget
// @Tags                        User
// @Description        Get User actual budget
// @Produce                json
// @Success                200                {object}        Response[transfer_models.BudgetActualResponse]        "Show actual budget"
// @Failure                400                {object}        http.Error                        "Client error"
// @Failure                500                {object}        http.Error                        "Server error"
// @Router                /api/user/{userID}/actualBudget [get]
func (h *Handler) GetCurrentBudget(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := commonHttp.GetIDFromRequest(userIdUrlParam, r)

        if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, commonHttp.InvalidURLParameter, h.logger)
                return
        }</span>

        <span class="cov8" title="1">budget, err := h.userService.GetCurrentBudget(userID)

        // var errNoSuchCurrentBudget *models.NoSuchCurrentBudget
        // if errors.As(err, &amp;errNoSuchCurrentBudget) {
        //         commonHttp.ErrorResponse(w, http.StatusBadRequest, err, transfer_models.CurrentBudgetNotFound, h.logger)
        //         return
        // }

        if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusInternalServerError, err, transfer_models.CurrentBudgetGetServerError, h.logger)
                return
        }</span>

        <span class="cov8" title="1">response := transfer_models.BudgetActualResponse{BudgetActual: budget}
        commonHttp.SuccessResponse[transfer_models.BudgetActualResponse](w, http.StatusOK, response)</span>
}

// @Summary                Get User Accounts
// @Tags                        User
// @Description        Get User accounts
// @Produce                json
// @Success                200                {object}        Response[transfer_models.Account]                     "Show actual accounts"
// @Failure                400                {object}        http.Error                "Client error"
// @Failure                500                {object}        http.Error                "Server error"
// @Router                /api/user/{userID}/accounts/all [get]
func (h *Handler) GetAccounts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := commonHttp.GetIDFromRequest(userIdUrlParam, r)

        if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, commonHttp.InvalidURLParameter, h.logger)
                return
        }</span>

        <span class="cov8" title="1">accountInfo, err := h.userService.GetAccounts(userID)

        var errNoSuchAccounts *models.NoSuchAccounts

        if errors.As(err, &amp;errNoSuchAccounts) </span><span class="cov8" title="1">{
                h.logger.Info(err.Error())
                commonHttp.SuccessResponse(w, http.StatusOK, "")
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusInternalServerError, err, transfer_models.AccountNotFound, h.logger)
                return
        }</span>

        <span class="cov8" title="1">response := transfer_models.Account{AccountMas: accountInfo}
        commonHttp.SuccessResponse[transfer_models.Account](w, http.StatusOK, response)</span>
}

// @Summary                Get User Accounts
// @Tags                        User
// @Description        Get User accounts
// @Produce                json
// @Success                200                {object}        Response[transfer_models.UserFeed]                     "Show actual accounts"
// @Failure                400                {object}        http.Error                "Client error"
// @Failure                500                {object}        http.Error                "Server error"
// @Router                /api/user/{userID}/feed [get]
func (h *Handler) GetFeed(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        status := http.StatusOK
        userID, err := commonHttp.GetIDFromRequest(userIdUrlParam, r)

        if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, commonHttp.InvalidURLParameter, h.logger)
                return
        }</span>

        <span class="cov8" title="1">dataFeed, err := h.userService.GetFeed(userID)

        var errNoSuchPlannedBudgetError *models.NoSuchPlannedBudgetError
        var errNoSuchUserIdBalanceError *models.NoSuchUserIdBalanceError
        var errNoSuchAccounts *models.NoSuchAccounts

        if errors.As(err, &amp;errNoSuchAccounts) ||
                errors.As(err, &amp;errNoSuchPlannedBudgetError) ||
                errors.As(err, &amp;errNoSuchUserIdBalanceError) </span><span class="cov8" title="1">{

                commonHttp.ErrorResponse(w, http.StatusBadRequest, err, transfer_models.UserFeedNotFound, h.logger)
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                commonHttp.ErrorResponse(w, http.StatusInternalServerError, err, transfer_models.UserFeedServerError, h.logger)
                return
        }</span>

        <span class="cov8" title="1">commonHttp.SuccessResponse(w, status, dataFeed)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package usecase

import (
        "fmt"

        "github.com/go-park-mail-ru/2023_2_Hamster/internal/common/logger"
        "github.com/go-park-mail-ru/2023_2_Hamster/internal/models"
        "github.com/go-park-mail-ru/2023_2_Hamster/internal/pkg/user"
        tranfer_models "github.com/go-park-mail-ru/2023_2_Hamster/internal/pkg/user/delivery/http/transfer_models"

        "github.com/google/uuid"
)

type Usecase struct {
        userRepo user.Repository
        logger   logger.CustomLogger
}

func NewUsecase(
        ur user.Repository,
        log logger.CustomLogger) *Usecase <span class="cov8" title="1">{
        return &amp;Usecase{
                userRepo: ur,
                logger:   log,
        }
}</span>

func (u *Usecase) GetUser(userID uuid.UUID) (*models.User, error) <span class="cov0" title="0">{ // need test
        user, err := u.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return user, fmt.Errorf("[usecase] can't get user from repository %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (u *Usecase) GetUserBalance(userID uuid.UUID) (float64, error) <span class="cov8" title="1">{
        balance, err := u.userRepo.GetUserBalance(userID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("[usecase] can't get balance from repository %w", err)
        }</span>

        <span class="cov8" title="1">return balance, nil</span>
}

func (u *Usecase) GetPlannedBudget(userID uuid.UUID) (float64, error) <span class="cov8" title="1">{
        balance, err := u.userRepo.GetPlannedBudget(userID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("[usecase] can't get planned budget from repository %w", err)
        }</span>

        <span class="cov8" title="1">return balance, nil</span>
}

func (u *Usecase) GetCurrentBudget(userID uuid.UUID) (float64, error) <span class="cov8" title="1">{
        transactionExpenses, err := u.userRepo.GetCurrentBudget(userID)

        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("[usecase] can't get current budget from repository %w", err)
        }</span>

        <span class="cov8" title="1">plannedBudget, err := u.userRepo.GetPlannedBudget(userID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("[usecase] can't get planned budget from repository %w", err)
        }</span>

        <span class="cov8" title="1">currentBudget := plannedBudget - transactionExpenses
        return currentBudget, nil</span>
}

func (u *Usecase) GetAccounts(userID uuid.UUID) ([]models.Accounts, error) <span class="cov8" title="1">{
        account, err := u.userRepo.GetAccounts(userID)
        if err != nil </span><span class="cov8" title="1">{

                return account, fmt.Errorf("[usecase] can't get accounts from repository %w", err)
        }</span>

        <span class="cov8" title="1">return account, nil</span>
}

func (u *Usecase) GetFeed(userID uuid.UUID) (tranfer_models.UserFeed, error) <span class="cov0" title="0">{ // need test!
        var dataTranfer tranfer_models.UserFeed
        var err error

        dataTranfer.Balance, err = u.GetUserBalance(userID)
        if err != nil </span><span class="cov0" title="0">{
                return dataTranfer, err
        }</span>

        <span class="cov0" title="0">dataTranfer.BudgetActual, err = u.GetCurrentBudget(userID)
        if err != nil </span><span class="cov0" title="0">{
                return dataTranfer, err
        }</span>

        <span class="cov0" title="0">dataTranfer.BudgetPlanned, err = u.GetPlannedBudget(userID)
        if err != nil </span><span class="cov0" title="0">{
                return dataTranfer, err
        }</span>

        <span class="cov0" title="0">dataTranfer.AccountMas, err = u.GetAccounts(userID)
        if err != nil </span><span class="cov0" title="0">{
                return dataTranfer, err
        }</span>

        <span class="cov0" title="0">return dataTranfer, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
